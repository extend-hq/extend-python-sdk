# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from .classifier import Classifier
from .classifier_version import ClassifierVersion
from .classify_run import ClassifyRun
from .edit_run import EditRun
from .extract_run import ExtractRun
from .extractor import Extractor
from .extractor_version import ExtractorVersion
from .parse_run_status import ParseRunStatus
from .split_run import SplitRun
from .splitter import Splitter
from .splitter_version import SplitterVersion
from .step_run import StepRun
from .workflow import Workflow
from .workflow_run import WorkflowRun


class WebhookEvent_WorkflowRunCompleted(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["workflow_run.completed"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="workflow_run.completed")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: WorkflowRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["workflow_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="workflow_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: WorkflowRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowRunNeedsReview(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["workflow_run.needs_review"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="workflow_run.needs_review")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: WorkflowRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowRunRejected(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["workflow_run.rejected"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="workflow_run.rejected")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: WorkflowRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowRunCancelled(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["workflow_run.cancelled"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="workflow_run.cancelled")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: WorkflowRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowRunStepRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["workflow_run.step_run.processed"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="workflow_run.step_run.processed")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: StepRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["extract_run.processed"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="extract_run.processed")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ExtractRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["extract_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="extract_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ExtractRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifyRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["classify_run.processed"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="classify_run.processed")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ClassifyRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifyRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["classify_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="classify_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ClassifyRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["split_run.processed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="split_run.processed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: SplitRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["split_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="split_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: SplitRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ParseRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["parse_run.processed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="parse_run.processed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ParseRunStatus

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ParseRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["parse_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="parse_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ParseRunStatus

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_EditRunProcessed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["edit_run.processed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="edit_run.processed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: EditRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_EditRunFailed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["edit_run.failed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="edit_run.failed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: EditRun

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowCreated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["workflow.created"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="workflow.created")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Workflow

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowDeployed(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["workflow.deployed"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="workflow.deployed")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Workflow

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_WorkflowDeleted(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["workflow.deleted"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="workflow.deleted")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Workflow

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractorCreated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["extractor.created"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="extractor.created")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Extractor

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractorUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["extractor.updated"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="extractor.updated")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Extractor

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractorDeleted(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["extractor.deleted"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="extractor.deleted")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Extractor

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractorDraftUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["extractor.draft.updated"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="extractor.draft.updated")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Extractor

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ExtractorVersionPublished(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["extractor.version.published"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="extractor.version.published")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ExtractorVersion

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifierCreated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["classifier.created"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="classifier.created")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Classifier

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifierUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["classifier.updated"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="classifier.updated")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Classifier

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifierDeleted(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["classifier.deleted"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="classifier.deleted")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Classifier

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifierDraftUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["classifier.draft.updated"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="classifier.draft.updated")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Classifier

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_ClassifierVersionPublished(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["classifier.version.published"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="classifier.version.published")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: ClassifierVersion

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitterCreated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["splitter.created"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="splitter.created")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Splitter

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitterUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["splitter.updated"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="splitter.updated")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Splitter

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitterDeleted(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[typing.Literal["splitter.deleted"], FieldMetadata(alias="eventType")] = (
        pydantic.Field(alias="eventType", default="splitter.deleted")
    )
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Splitter

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitterDraftUpdated(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["splitter.draft.updated"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="splitter.draft.updated")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: Splitter

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class WebhookEvent_SplitterVersionPublished(UncheckedBaseModel):
    """
    Union of all webhook event types. Use `eventType` as the discriminator
    to determine the specific event type and narrow the `payload` type.

    Example usage in TypeScript:
    ```typescript
    function handleWebhook(event: Extend.WebhookEvent) {
      switch (event.eventType) {
        case "workflow_run.completed":
          // event.payload is typed as WorkflowRun
          console.log(event.payload.status);
          break;
        case "extract_run.processed":
          // event.payload is typed as ExtractRun
          console.log(event.payload.output);
          break;
      }
    }
    ```
    """

    event_type: typing_extensions.Annotated[
        typing.Literal["splitter.version.published"], FieldMetadata(alias="eventType")
    ] = pydantic.Field(alias="eventType", default="splitter.version.published")
    event_id: typing_extensions.Annotated[str, FieldMetadata(alias="eventId")] = pydantic.Field(alias="eventId")
    payload: SplitterVersion

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


WebhookEvent = typing_extensions.Annotated[
    typing.Union[
        WebhookEvent_WorkflowRunCompleted,
        WebhookEvent_WorkflowRunFailed,
        WebhookEvent_WorkflowRunNeedsReview,
        WebhookEvent_WorkflowRunRejected,
        WebhookEvent_WorkflowRunCancelled,
        WebhookEvent_WorkflowRunStepRunProcessed,
        WebhookEvent_ExtractRunProcessed,
        WebhookEvent_ExtractRunFailed,
        WebhookEvent_ClassifyRunProcessed,
        WebhookEvent_ClassifyRunFailed,
        WebhookEvent_SplitRunProcessed,
        WebhookEvent_SplitRunFailed,
        WebhookEvent_ParseRunProcessed,
        WebhookEvent_ParseRunFailed,
        WebhookEvent_EditRunProcessed,
        WebhookEvent_EditRunFailed,
        WebhookEvent_WorkflowCreated,
        WebhookEvent_WorkflowDeployed,
        WebhookEvent_WorkflowDeleted,
        WebhookEvent_ExtractorCreated,
        WebhookEvent_ExtractorUpdated,
        WebhookEvent_ExtractorDeleted,
        WebhookEvent_ExtractorDraftUpdated,
        WebhookEvent_ExtractorVersionPublished,
        WebhookEvent_ClassifierCreated,
        WebhookEvent_ClassifierUpdated,
        WebhookEvent_ClassifierDeleted,
        WebhookEvent_ClassifierDraftUpdated,
        WebhookEvent_ClassifierVersionPublished,
        WebhookEvent_SplitterCreated,
        WebhookEvent_SplitterUpdated,
        WebhookEvent_SplitterDeleted,
        WebhookEvent_SplitterDraftUpdated,
        WebhookEvent_SplitterVersionPublished,
    ],
    UnionMetadata(discriminant="event_type"),
]
update_forward_refs(WebhookEvent_WorkflowRunCompleted)
update_forward_refs(WebhookEvent_WorkflowRunFailed)
update_forward_refs(WebhookEvent_WorkflowRunNeedsReview)
update_forward_refs(WebhookEvent_WorkflowRunRejected)
update_forward_refs(WebhookEvent_WorkflowRunCancelled)
update_forward_refs(WebhookEvent_WorkflowRunStepRunProcessed)
update_forward_refs(WebhookEvent_ExtractRunProcessed)
update_forward_refs(WebhookEvent_ExtractRunFailed)
update_forward_refs(WebhookEvent_EditRunProcessed)
update_forward_refs(WebhookEvent_EditRunFailed)
update_forward_refs(WebhookEvent_ExtractorCreated)
update_forward_refs(WebhookEvent_ExtractorUpdated)
update_forward_refs(WebhookEvent_ExtractorDeleted)
update_forward_refs(WebhookEvent_ExtractorDraftUpdated)
update_forward_refs(WebhookEvent_ExtractorVersionPublished)
