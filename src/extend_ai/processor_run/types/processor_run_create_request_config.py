# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, update_forward_refs
from ...core.serialization import FieldMetadata
from ...core.unchecked_base_model import UncheckedBaseModel, UnionMetadata
from ...types.json_object import JsonObject
from ...types.legacy_classification import LegacyClassification
from ...types.legacy_classification_advanced_options import LegacyClassificationAdvancedOptions
from ...types.legacy_classification_config_base_processor import LegacyClassificationConfigBaseProcessor
from ...types.legacy_extraction_advanced_options import LegacyExtractionAdvancedOptions
from ...types.legacy_extraction_config_base_processor import LegacyExtractionConfigBaseProcessor
from ...types.legacy_splitter_advanced_options import LegacySplitterAdvancedOptions
from ...types.legacy_splitter_config_base_processor import LegacySplitterConfigBaseProcessor
from ...types.parse_config import ParseConfig


class ProcessorRunCreateRequestConfig_Classify(UncheckedBaseModel):
    """
    The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.
    """

    type: typing.Literal["CLASSIFY"] = "CLASSIFY"
    base_processor: typing_extensions.Annotated[
        typing.Optional[LegacyClassificationConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = pydantic.Field(alias="baseProcessor", default=None)
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = (
        pydantic.Field(alias="baseVersion", default=None)
    )
    classifications: typing.List[LegacyClassification]
    classification_rules: typing_extensions.Annotated[
        typing.Optional[str], FieldMetadata(alias="classificationRules")
    ] = pydantic.Field(alias="classificationRules", default=None)
    advanced_options: typing_extensions.Annotated[
        typing.Optional[LegacyClassificationAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = pydantic.Field(alias="advancedOptions", default=None)
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class ProcessorRunCreateRequestConfig_Extract(UncheckedBaseModel):
    """
    The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.
    """

    type: typing.Literal["EXTRACT"] = "EXTRACT"
    base_processor: typing_extensions.Annotated[
        typing.Optional[LegacyExtractionConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = pydantic.Field(alias="baseProcessor", default=None)
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = (
        pydantic.Field(alias="baseVersion", default=None)
    )
    extraction_rules: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="extractionRules")] = (
        pydantic.Field(alias="extractionRules", default=None)
    )
    schema_: typing_extensions.Annotated[typing.Optional[JsonObject], FieldMetadata(alias="schema")] = pydantic.Field(
        alias="schema", default=None
    )
    fields: typing.Optional[typing.List["LegacyExtractionField"]] = None
    advanced_options: typing_extensions.Annotated[
        typing.Optional[LegacyExtractionAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = pydantic.Field(alias="advancedOptions", default=None)
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class ProcessorRunCreateRequestConfig_Splitter(UncheckedBaseModel):
    """
    The configuration for the processor run. If this is provided, this config will be used. If not provided, the config for the specific version you provide will be used. The type of configuration must match the processor type.
    """

    type: typing.Literal["SPLITTER"] = "SPLITTER"
    base_processor: typing_extensions.Annotated[
        typing.Optional[LegacySplitterConfigBaseProcessor], FieldMetadata(alias="baseProcessor")
    ] = pydantic.Field(alias="baseProcessor", default=None)
    base_version: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="baseVersion")] = (
        pydantic.Field(alias="baseVersion", default=None)
    )
    split_classifications: typing_extensions.Annotated[
        typing.List[LegacyClassification], FieldMetadata(alias="splitClassifications")
    ] = pydantic.Field(alias="splitClassifications")
    split_rules: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="splitRules")] = pydantic.Field(
        alias="splitRules", default=None
    )
    advanced_options: typing_extensions.Annotated[
        typing.Optional[LegacySplitterAdvancedOptions], FieldMetadata(alias="advancedOptions")
    ] = pydantic.Field(alias="advancedOptions", default=None)
    parser: typing.Optional[ParseConfig] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


ProcessorRunCreateRequestConfig = typing_extensions.Annotated[
    typing.Union[
        ProcessorRunCreateRequestConfig_Classify,
        ProcessorRunCreateRequestConfig_Extract,
        ProcessorRunCreateRequestConfig_Splitter,
    ],
    UnionMetadata(discriminant="type"),
]
from ...types.legacy_extraction_field import LegacyExtractionField  # noqa: E402, I001

update_forward_refs(ProcessorRunCreateRequestConfig_Extract, LegacyExtractionField=LegacyExtractionField)
